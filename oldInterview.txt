previous Interview questions

1. can you walk me through your resume.

I am a core UI Developer with 12+ years of experience building .com websites for different organizations using HTML5, CSS3, JavaScript, React.js, and Redux. 
In the past 2 years, I worked on the React migration team, where I converted the .net pages to react on united.com. 
Frontend is React, and used ATMOS (Own library) components used company wide.

Worked on Security features for users where they can manage there account like Forgot password, Forgot MileagePlus number, security questions, Sign-in features, Miles-Pooling, United Club pass,  Recent Activity, dashboard updates and KTN(Known Traveler Number), Accessibility guidelines features on united.com.

used middleware such as redux-saga to handle asynchronous tasks such as API calls, data fetching, and impure actions in a more organized and efficient way.

The new initiative worked on Miles-Pooling( points you get after traveling), TSA Precheck, Account security and management features, and Under18.

Previously worked with Accelerator team for Visa Inc. remediation of MBDA modules like Application Management, Account Management, Portfolio Management, Analytics, Recurring billing, Virtual Terminal, etc for bank users like Wells Fargo,  Bank of America, etc

Capital Group worked on DAVIS Project. Davis stands for Data visualization where we build different highcharts using react and integrate into the AEM., the backend is Java. Previously I worked on Creative Workbench, a writing tool where articles are published on capital group websites.

At Cerner Corporation worked on the medical examination forms.

In Office Depot worked on black Friday reporting.

Satinos Technologies created a tax portal and a schoomin website for the Vignan schools.


1. Introduce yourself?
I’m a Senior Full Stack Engineer with 12+ years of experience building .com websites using HTML5, CSS3, JavaScript, React.js, and Redux. 
For the last 2 years at United Airlines, I’ve been on the React migration team converting .NET pages to React using our in-house ATMOS library. 
I delivered several security and account management features like Forgot Password, MileagePlus sign-in, Miles-Pooling, TSA Precheck, Known Traveler Number (KTN), and WCAG accessibility updates. 
Redux-Saga handled our async flows for data fetching and API calls. 
Key initiatives included Miles-Pooling (rewards sharing), TSA Precheck integration, Under18 account restrictions, and enhanced account security. 
Previously: 
• Visa Inc. – Migrated MBDA modules (Application Mgmt, Portfolio Mgmt, Billing, Analytics) for Wells Fargo, Bank of America. 
• Capital Group – Built Highcharts data visualizations in React, integrated with AEM, and created Creative Workbench for article publishing. 
• Cerner – Developed medical examination forms. 
• Office Depot – Built Black Friday reporting tools. 
• Satinos Technologies – Developed a tax portal and school website for Vignan Schools.


2. code split in react?
Code splitting is a technique to split the React app bundle into smaller chunks so the browser only loads what’s needed. 
In React, we usually do this with React.lazy and Suspense or route-based splitting. 
This improves performance by reducing initial load time and loading components on demand.


3. HOC (Higher-Order Component)?
A Higher-Order Component (HOC) is a function that takes a component as input and returns a new component with additional props or logic. 
It’s mainly used for reusing component logic, like authentication checks, theming, or data fetching.

4. pure component vs class component

Class Component → re-renders by default.

Pure Component → re-renders only if props/state actually change (shallow check).

5. how to enable dark and light theme
We can enable dark and light themes by maintaining a theme state (e.g., light or dark) and applying conditional class names or CSS variables. 
A common approach is using CSS custom properties or a library like Material-UI’s ThemeProvider. 
The user’s preference can be saved in localStorage or matched with the system preference using window.matchMedia.



6. how to avoid rerendering?
To avoid unnecessary re-renders, we can use techniques like React.memo for functional components, useMemo for memoizing expensive calculations, and useCallback for memoizing functions. 
Also, keeping state local to where it’s needed, avoiding prop changes that aren’t required, and using keys correctly help reduce re-renders.

7. example for usecallback
useCallback memoizes a function so it doesn’t get recreated on every render. 
It’s useful when passing functions as props to child components, to prevent unnecessary re-renders.


8. React Transition API (useTransition)
useTransition is a React hook that lets you mark state updates as non-urgent (transitions). 
Urgent updates like typing happen immediately, while transition updates (like filtering a large list) can be deferred so the UI stays responsive.


9. custom font implementation vijay

To use custom fonts in React, you can add them via CSS @font-face, link them in index.html (Google Fonts/CDN), or import them in your CSS/SCSS. 
Once defined, you just apply them with font-family.

React.js Developer Interview Cheatsheet

Core React.js Topics

1. useState

What: Lets you add local state to a functional component.

Why: Store values that change over time (form input, toggle, counters).

const [count, setCount] = useState(0);

2. useEffect

What: Runs side effects after render (data fetch, event listeners, DOM manipulation).

Why: Keeps logic tied to lifecycle (mount, update, unmount).

useEffect(() => {
  fetchData();
  return () => cleanup(); // optional cleanup
}, [dependencies]);

3. useMemo

What: Memoizes a computed value so it doesn’t recalc on every render.

Why: Optimize expensive calculations.

const result = useMemo(() => heavyCompute(data), [data]);

4. useCallback

What: Memoizes a function so it’s not re-created on each render.

Why: Prevents unnecessary re-renders of child components.

const handleClick = useCallback(() => doSomething(value), [value]);

5. useRef

What: Stores a mutable value that survives re-renders (doesn’t trigger rerender).

Why: Useful for DOM refs, timers, or storing previous values.

const inputRef = useRef(null);
<input ref={inputRef} />;

6. useContext

What: Access global data without prop drilling.

Why: Share theme, auth, or user info across components.

const theme = useContext(ThemeContext);

7. useReducer

What: Alternative to useState for complex state logic with actions & reducers.

Why: Manages complex state transitions (like Redux but local).

const [state, dispatch] = useReducer(reducer, initialState);
dispatch({ type: "INCREMENT" });

8. useTransition (React 18+)
Why: Prevents blocking UI during heavy renders.

const [isPending, startTransition] = useTransition();
startTransition(() => {
  setFilter(query); // deferred update
});



2. useMemo vs useCallback: useMemo memoizes values, useCallback memoizes functions

useMemo

Purpose: Memoizes the result of a computation.

When: Expensive calculations or derived data that shouldn’t re-run unless dependencies change.

const sortedList = useMemo(() => heavySort(list), [list]);

Think: “Cache a value.”

useCallback

Purpose: Memoizes the function itself.

When: Passing callbacks to child components to prevent re-renders (when wrapped in React.memo).

const handleClick = useCallback(() => doSomething(id), [id]);

Think: “Cache a function.”




State Management: Context API vs Redux Toolkit, when to choose Redux over Context, async flows with Thunk or Saga

Context API

What: Native React feature to share state globally without prop drilling.

When: Great for small to medium apps, or when you only need to share simple state (theme, auth, user info).

Limitations: Not built for very complex state logic, no built-in dev tools, debugging is harder.

Redux Toolkit

What: Official, modern way to use Redux with less boilerplate.

When: Best for large apps with complex, shared state and multiple slices of data. Comes with powerful tooling: time-travel debugging, middleware, immutability, async handling.

Extras: Built-in integration with TypeScript, Immer, RTK Query.

When to choose Redux over Context

Multiple features/modules need to share and update state consistently.

Complex state transitions (beyond toggles, theme, or auth).

Need predictability + middleware (logging, analytics, persistence).

Team collaboration requires clear patterns and dev tools.

👉 Rule of thumb:

Small/simple app: Context API.

Enterprise/complex app: Redux Toolkit.

Async flows: Thunk vs Saga

Redux Thunk

Middleware to handle async logic (returns functions instead of actions).

Simple and straightforward for API calls.

const fetchUsers = () => async (dispatch) => {
  const data = await api.get("/users");
  dispatch(setUsers(data));
};


Redux Saga

Uses ES6 generators for async.

Powerful for complex async workflows, retries, cancellations, sequencing.

More scalable for large apps with lots of side effects.

function* fetchUsersSaga() {
  const data = yield call(api.get, "/users");
  yield put(setUsers(data));
}


• Component Optimization: React.memo, keys, virtualization, batching, lazy loading + Suspense

1. React.memo

What: Higher-order component that memoizes functional components.

Why: Prevents re-render if props haven’t changed.

const MyComponent = React.memo(({ value }) => <div>{value}</div>);

2. Keys

What: Unique identifier for list items.

Why: Helps React’s diffing algorithm know which items changed, added, or removed.

Bad keys cause: Extra re-renders, wrong DOM updates.

list.map(item => <li key={item.id}>{item.name}</li>);

3. Virtualization

What: Render only what’s visible in the viewport (e.g., react-window, react-virtualized).

Why: Huge lists (10k+) won’t kill performance.

<FixedSizeList height={400} itemCount={1000} itemSize={35}>
  {Row}
</FixedSizeList>

4. Batching

What: React groups multiple state updates into a single render for performance.

Why: Reduces unnecessary re-renders.

React 18+: Automatic batching even inside async handlers.

setCount(c => c + 1);
setFlag(f => !f); // both happen in one render

5. Lazy Loading + Suspense

What: Code splitting for components. Loads chunks only when needed.

Why: Smaller initial bundle, faster page load.

const Profile = React.lazy(() => import("./Profile"));
<Suspense fallback={<Spinner />}>
  <Profile />
</Suspense>



• JSX & Rendering: Virtual DOM vs Real DOM, reconciliation & diffing, controlled vs uncontrolled
components

JSX

What: Syntax sugar for React.createElement(). Looks like HTML but compiles to JS objects.

Why: Easier to write UI and blend markup + logic.

const element = <h1>Hello</h1>; 
// Compiles to React.createElement("h1", null, "Hello")

Virtual DOM vs Real DOM

Real DOM: Actual browser DOM. Slow to update when changes are frequent.

Virtual DOM: Lightweight JS representation of the DOM.

Why: React updates the virtual DOM, then diffs it against the old one, and updates only what changed in the real DOM.

👉 Benefit: Faster updates, fewer reflows.

Reconciliation & Diffing

Reconciliation: Process React uses to update the DOM.

Diffing: Algorithm that finds minimal changes by comparing old and new virtual DOM trees.

Example:

If only one item in a list changes, React updates just that node, not the whole list.

Keys matter here: They tell React which items are stable across renders.

Controlled vs Uncontrolled Components

Controlled: Form input values are managed by React state.

Predictable, easy validation.

const [name, setName] = useState("");
<input value={name} onChange={e => setName(e.target.value)} />


Uncontrolled: Form inputs store their own state in the DOM. You use refs to read values.

Less boilerplate, but harder validation.

const inputRef = useRef();
<input ref={inputRef} />


👉 Rule of thumb: Controlled for most forms (validation, business logic). Uncontrolled for simple or performance-heavy forms.


2. Advanced React

• Code Splitting & Lazy Loading: React.lazy + Suspense
• Error Boundaries: Handle runtime crashes in class components
• SSR vs CSR vs SSG: SEO and performance trade-offs

1. Code Splitting & Lazy Loading

Code Splitting: Breaks your JS bundle into smaller chunks. Only loads what’s needed.

Lazy Loading: Load a component or module only when it’s required.

React Implementation: React.lazy() with Suspense.

const Profile = React.lazy(() => import("./Profile"));

<Suspense fallback={<Spinner />}>
  <Profile />
</Suspense>


👉 Benefit: Faster initial load, better performance.

2. Error Boundaries

What: Special React components (class-based) that catch JS errors in child components during rendering, lifecycle, or constructors.

Why: Prevents app from crashing entirely — show fallback UI instead.

class ErrorBoundary extends React.Component {
  state = { hasError: false };
  static getDerivedStateFromError() { return { hasError: true }; }
  componentDidCatch(error, info) { logError(error, info); }
  render() { return this.state.hasError ? <h1>Something went wrong.</h1> : this.props.children; }
}


👉 Note: They don’t catch errors in event handlers or async code.

3. SSR vs CSR vs SSG

CSR (Client-Side Rendering):

Browser downloads a blank HTML + JS bundle. React renders on client.

Pros: Interactive apps, fast navigation after first load.

Cons: Slower first paint, SEO weaker.

Example: Create React App.

SSR (Server-Side Rendering):

HTML rendered on the server, sent fully built to client. React hydrates after.

Pros: Faster first paint, better SEO, good for content-heavy sites.

Cons: Higher server cost, more complex setup.

Example: Next.js with SSR.

SSG (Static Site Generation):

Pages are pre-built at build time, served as static HTML.

Pros: Super fast, very cheap to serve, great SEO.

Cons: Not good for frequently changing data (needs re-builds).

Example: Next.js getStaticProps.

👉 Trade-off Summary:

CSR → Great for apps.

SSR → Great for SEO + dynamic content.

SSG → Great for blogs, docs, marketing sites.



3. JavaScript & TypeScript Refresh
• ES6+: let/const, arrow functions, destructuring, async/await, promises
• Event Loop: microtasks vs macrotasks
• Deep copy vs shallow copy
• TypeScript: interfaces vs types

ES6+

let/const vs var

var: function-scoped, hoisted.

let: block-scoped, reassignable.

const: block-scoped, immutable binding.

Arrow functions

Short syntax, lexical this (doesn’t bind its own).

const add = (a, b) => a + b;


Destructuring

Extract values from arrays/objects easily.

const { name, age } = user;


Promises & async/await

Promise: handles async with .then/.catch.

async/await: syntactic sugar for cleaner async code.

const data = await fetch("/api").then(r => r.json());

Event Loop: Microtasks vs Macrotasks

Macrotask Queue: setTimeout, setInterval, setImmediate.

Microtask Queue: Promises (.then, .catch), MutationObserver, queueMicrotask.

Rule: Microtasks run before next macrotask.

setTimeout(() => console.log("macro"), 0);
Promise.resolve().then(() => console.log("micro"));
// Output: micro → macro

Deep Copy vs Shallow Copy

Shallow Copy: Copies top-level only, nested objects still reference original.

Example: Object.assign({}, obj) or { ...obj }.

Deep Copy: Creates new copies of all nested objects.

Example: structuredClone(obj) (modern), or JSON.parse(JSON.stringify(obj)).
👉 Use deep copy when mutating nested objects, to avoid bugs.

TypeScript: Interfaces vs Types

Interface

Describes object shape, extendable (declaration merging).

interface User { name: string; age: number; }


Type Alias

Defines any type (union, primitive, tuple, etc.).

Cannot merge declarations.

type User = { name: string; age: number; };
type Status = "success" | "error";


👉 Rule of thumb:

Use interface for objects/contracts you want to extend.

Use type for unions, primitives, and advanced type composition.



4. System/Architecture
• Micro Frontends: Module Federation, pros & cons
• Design Systems: consistency across apps
• Security in React: prevent XSS, sanitize inputs, JWT/OAuth2, HTTPS
• Accessibility (WCAG): aria-labels, keyboard navigation, color contrast

1. Micro Frontends (MFE)

What: Breaking a large frontend into smaller, independently deployable apps.

How: Webpack Module Federation, single-spa, Nx, etc.

Pros:

Teams work independently (different stacks possible).

Faster deployments (ship a single feature).

Easier scaling.

Cons:

Complex setup (routing, shared state).

Larger bundle size if dependencies aren’t shared.

Harder end-to-end testing.

👉 One-liner: “MFEs let you scale frontend like microservices, but add complexity in integration and performance.”

2. Design Systems

What: A reusable library of UI components + styles (like Material UI, in-house ATMOS, Chakra).

Why:

Consistency across products.

Faster dev cycles.

Easy adoption of accessibility and brand standards.

Example: Buttons, inputs, modals, typography tokens.

👉 One-liner: “Design systems enforce consistency, improve dev speed, and ensure accessibility is built-in.”

3. Security in React

Prevent XSS: Never inject raw HTML (dangerouslySetInnerHTML). Escape/sanitize user inputs.

Sanitize Inputs: Use libs like DOMPurify. Validate on both client & server.

Authentication:

JWT (JSON Web Token): stateless, stored in cookies/secure storage.

OAuth2: for third-party identity providers (Google, Facebook, Okta).

Transport Security: Always use HTTPS. Add CSP (Content Security Policy).

👉 One-liner: “React security means preventing XSS, sanitizing inputs, using JWT/OAuth2 for auth, and enforcing HTTPS.”

4. Accessibility (WCAG)

WCAG: Web Content Accessibility Guidelines.

Practices:

ARIA labels: <button aria-label="Close" />.

Keyboard navigation: tabIndex, focus management.

Color contrast: Meet AA/AAA standards.

Screen readers: Use semantic HTML (<nav>, <header>).

Testing: axe-core, Lighthouse, NVDA/VoiceOver.

👉 One-liner: “Accessibility is making apps usable for everyone — proper ARIA, keyboard support, and contrast checks following WCAG 2.1.”




5. Behavioral
• Use STAR (Situation, Task, Action, Result) for experience-based answers
• Examples: United Airlines migration (.NET to React, ATMOS, Redux-Saga, Miles Pooling)
• Mentorship: code reviews, pairing, knowledge-sharing
• Challenges: async flows, performance, accessibility compliance

STAR Method Refresher

S – Situation: Context/background.

T – Task: What was expected of you.

A – Action: What you did.

R – Result: The outcome (quantifiable if possible).

👉 Keep answers tight, 1–2 minutes each, highlight leadership + impact.

Example 1 – United Airlines Migration

Situation: Legacy .NET pages were slow and hard to maintain. Needed migration to React.

Task: Lead React migration team to modernize user account features.

Action:

Migrated .NET pages to React using ATMOS library.

Implemented Redux-Saga for async flows (login, password reset).

Built features like Miles Pooling, TSA PreCheck, and Known Traveler Number integration.

Enforced WCAG compliance (screen readers, keyboard navigation).

Result: Reduced page load time by ~30%, improved accessibility score to AA, and shipped secure account features used by millions.

Example 2 – Mentorship

Situation: Team had a mix of senior and junior devs.

Task: Ensure high-quality code delivery and upskill team.

Action:

Led code reviews with emphasis on readability and performance.

Paired with juniors to debug complex async flows.

Ran short knowledge-sharing sessions on hooks, Redux-Saga, and accessibility.

Result: Improved onboarding speed for new hires, reduced PR rework by ~40%.

Example 3 – Overcoming Challenges

Async Flows: API chaining was messy → standardized async handling with Redux-Saga.

Performance: Large pages re-rendering → optimized with React.memo, virtualization.

Accessibility: Designers didn’t account for WCAG → added ARIA roles, screen reader testing.

Result: Cleaner architecture, faster UI, and compliance without slowing delivery.



6. Practice Questions
• Difference between functional and class components
• How React handles reconciliation?
• How to handle API calls with hooks?
• How to prevent prop drilling?
• Explain useReducer with an example
• Throttling vs debouncing (React use case)
• How to optimize a slow React app?

Difference between functional and class components

Functional: Plain functions, hooks for state/effects, smaller and faster to write, easier to test.

Class: extends React.Component, lifecycle methods, no hooks. Mostly legacy.

Today’s rule: Prefer functional + hooks; classes only for legacy/error boundaries.

How React handles reconciliation

React builds a virtual DOM for the new render, diffs it with the previous tree, and applies the minimal changes to the real DOM.

Heuristics: Different element type → replace subtree. Same type → update props and recurse.

Keys in lists tell React which items are stable; wrong keys cause extra re-renders or DOM glitches.

How to handle API calls with hooks

Use useEffect for lifecycle, store data with useState, handle cleanup and cancellation.

function Users() {
  const [users, setUsers] = React.useState([]);
  const [error, setError] = React.useState(null);
  React.useEffect(() => {
    const ctrl = new AbortController();
    (async () => {
      try {
        const res = await fetch("/api/users", { signal: ctrl.signal });
        if (!res.ok) throw new Error("Network error");
        setUsers(await res.json());
      } catch (e) { if (e.name !== "AbortError") setError(e.message); }
    })();
    return () => ctrl.abort();
  }, []);
  // render users or error...
}


For larger apps, prefer RTK Query, SWR, or React Query for caching, retries, deduping.

How to prevent prop drilling

Context API for cross-cutting concerns (theme, auth).

State libraries when state is complex/shared (Redux Toolkit, Zustand).

Collocate state: keep state near where it’s used; lift only when needed.

const AuthCtx = React.createContext(null);
// Provider at top; useContext() in deep children instead of passing props down many levels

Explain useReducer with an example

Good for complex state transitions or when next state depends on previous state.

const initial = { count: 0 };
function reducer(state, action) {
  switch (action.type) {
    case "inc": return { count: state.count + 1 };
    case "dec": return { count: state.count - 1 };
    case "set": return { count: action.value };
    default:    return state;
  }
}
function Counter() {
  const [state, dispatch] = React.useReducer(reducer, initial);
  return (
    <>
      <button onClick={() => dispatch({ type: "dec" })}>-</button>
      <span>{state.count}</span>
      <button onClick={() => dispatch({ type: "inc" })}>+</button>
    </>
  );
}


Pairs well with Context to create a small, Redux-like store.

Throttling vs debouncing (React use case)

Debounce: Wait until the user stops triggering the event, then run once.

Use for search input, resize-end. Prevents spammy calls.

Throttle: Run at most once every N ms while events continue.

Use for scroll position, window resize calculations.

// Debounce example (basic)
function useDebounce(fn, delay) {
  const t = React.useRef();
  return React.useCallback((...args) => {
    clearTimeout(t.current);
    t.current = setTimeout(() => fn(...args), delay);
  }, [fn, delay]);
}

How to optimize a slow React app
1.	Kill unnecessary re-renders
o	React.memo for pure child components.
o	useCallback/useMemo to stabilize props for memoized children.
o	Split large contexts; avoid context value churn.
2.	Reduce work per render
o	Move heavy calculations into useMemo.
o	Derived data/selectors instead of recomputing in render.
3.	Code splitting
o	React.lazy + Suspense for routes/feature modules.
4.	Virtualize long lists
o	react-window / react-virtualized.
5.	Minimize state surface
o	Keep state local; avoid putting everything in global state.
6.	Network/UI
o	Cache data (React Query/RTK Query), prefetch, paginate.
o	Images: proper sizes, lazy-load.
7.	SSR/SSG where it helps
o	Faster first paint and better SEO for content pages.
8.	Measure
o	Use React Profiler, Lighthouse, Performance tab. Fix the top offenders first.


What is Prototype chaining? Overriding the parent class functionality with child class functionality.
What is callbacks?  - Passing "one function" to "another function" as an argument called as "CallBack"
What is CallBack Hell?  Providing the tightly coupled code with call backs is called callback hell. 
What is the problem of Callback hell? Readability is less and difficult. Remedy for callback is promises.
Callback hell is Not a recommended code. Call add, sub, multiplication, division. It is  not easy to understand.


 Promises Establishes the communication between "producer" and "consumer".
 
        - Promises also called as "special javascript objects".
 
        - we will create Promises by using "Promise" class constructor.
 
        - Promises have 3 states
 
            1) success  (resolve)
 
            2) error    (reject)
 
            3) pending
 
        - we will consume promises by using "then()"

        To consume the promise we call async and await instead of then(). Latest released in ES9.

  HTML5 Supports two types of Storages.
             1) local storage
            2) session storage
 
    - whenever we "close the browser" or "opens the new tab" we won't lost the data from local storage.
 
    - whenever we "close the browser" or "opens the new tab" we will lost the data from session storage.
 
    - "localStorage" is the predefined object used to work with the local storage.
 
    - "sessionStorage" is the predefined object used to work with the session storage.
 
    - we will store the data in the form of a "key & value" pairs.

    Closure - if any inner function accessing the outer function data, then such scenario called as closure


1. tell me about yourself?

2. which version of react.js are using? v16.8, react 18, v19 dec 5th, 2024

3. what is async await?

In JavaScript, async and await are used to handle asynchronous operations in a more readable and manageable way, replacing traditional callback-based approaches.

Explanation
async function: Declares that a function returns a Promise, allowing you to use await inside it.

await keyword: Pauses execution until a Promise resolves, making asynchronous code look more like synchronous code.

Key Benefits
Makes asynchronous code easier to read.

Helps avoid callback hell.

Improves error handling with try-catch.

4.  what is synchronous vs asychronous?

Synchronous Code
Executes line by line, meaning each operation must finish before the next one starts.

Blocking: If one task takes a long time, everything after it waits.


Asynchronous Code
Executes without waiting for a previous task to complete.

Non-blocking: Tasks can run independently, allowing multiple operations to happen simultaneously.

Often uses callbacks, Promises, or async/await.

5. how to call multiple api calls simunatenously?

You can call multiple API requests simultaneously using Promise.all, Promise.allSettled, or async/await with parallel execution. 

Using Promise.all (Best for Successful Responses)

✅ Executes all requests in parallel ❌ Fails completely if one request errors out



Using Promise.allSettled (Handles Errors Gracefully)

✅ All requests execute, even if some fail ✅ Provides individual success/failure reports



Using async/await with Parallel Execution
✅ Parallel execution without Promise.all ✅ More control over individual responses

Which One Should You Use?
Use Promise.all when all API calls must succeed together.

Use Promise.allSettled when you want results even if some APIs fail.

Use async/await for a more manual approach with better readability.

6. what is controlled and uncontrolled components?

Use controlled components for most cases where React state should manage inputs.

Use uncontrolled components if you need direct DOM access or lightweight components.

7. what is Debouncing ?

Debouncing is a technique used to improve performance by limiting the rate at which a function executes. 
It ensures that a function (typically event handlers like input changes, scrolling, or resizing) only runs after a specified delay, preventing unnecessary executions.

8. What is useEffect hook?
The useEffect hook in React is a powerful tool used for managing side effects in functional components.
It allows you to run logic after the component renders, handling things like data fetching, subscriptions, or updating the DOM.

How Does useEffect Work?
It executes after the component renders.

Can run once, on updates, or on cleanup—depending on dependencies.

Helps avoid unnecessary logic inside the main component body.

9. did you work on custom hooks?
A custom hook in React is a reusable function that encapsulates logic using other React hooks (useState, useEffect, etc.). 
It allows you to extract common behavior from components and keep them clean and maintainable.

Common Use Cases for Custom Hooks
API calls (useFetch)

Local storage management (useLocalStorage)

Form validation

Handling authentication

Debouncing functions


10. how to make api call without useEffect?

You can make API calls in React without using useEffect by triggering them inside event handlers, functions, or lifecycle methods in class components.

11. What is promise.All() and race?

Both Promise.all and Promise.race are useful methods for handling multiple promises in JavaScript, but they behave differently.

Promise.all (Waits for All Promises to Resolve)
Promise.race (Returns the First Settled Promise)

12. How do you integrate 2 API in front end with useEffect?

Use Promise.all inside one useEffect → When both APIs need to be fetched together.

Use multiple useEffect hooks → When API calls are independent.

13. How Do Uncontrolled Components Work?

The value of an input field is stored directly in the DOM.

React does not track state updates for the input field.

You access the current value when needed, usually via useRef.

14. redux architecture? 

Redux is a state management library for JavaScript applications, commonly used with React. 
It follows a predictable, unidirectional data flow, making state management more manageable, especially for large applications.

Redux Data Flow
Redux follows a structured flow to ensure predictable state updates:

1️⃣ Action → Describes what happens (e.g., "ADD_ITEM"). 
2️⃣ Reducer → Handles the action and updates state. 
3️⃣ Store → Holds the global application state. 
4️⃣ View (React Component) → Receives state data and dispatches actions.

15. what is == vs ===

== and === are comparison operators, but they behave differently in terms of type coercion.

Which One Should You Use?

Use === (strict equality) in most cases to avoid unexpected behavior.

Use == only when intentional type conversion is required.

16. can you explain your implementation
// write code for 1 text field, enter the data.
// display table product id, name, description
//top of table display text field and search button - click on search need to show table with hardcode data.

17. have you worked as a LEAD?

"Yes, I’ve worked as a lead on multiple React projects. 
I was responsible for guiding the team on best practices, making architectural decisions, and ensuring scalable and maintainable code. 
I also mentored junior developers and conducted code reviews to maintain high coding standards. 
My role involved close collaboration with stakeholders to align development with business goals."

18. what is return and commit in JSX?

return is essential in JSX—it defines the UI a component renders.

commit is part of React’s internal lifecycle—it happens when React applies changes to the DOM.

Developers rarely interact with "commit" directly, but useEffect runs after React commits updates.

19. What is map()? and reduce()?

Use map() when transforming each item (e.g., formatting names, adjusting values).

Use reduce() when combining data into a single result (e.g., summing prices, merging arrays).

20. what is the output of map()?

The output of map() is always a new array with transformed elements based on the function provided.

✅ The original array remains unchanged ✅ The new array contains modified elements

Key Takeaways
map() always returns a new array (original array stays untouched).

The number of elements remains the same, unless explicitly modified.

Works well for transforming data (e.g., formatting, extracting values, modifying structures).

=======================================================================
React.js
Javascript
Coding question
HTML Questions



2. What is HOC?
A higher-order function is a function that treats other functions as data, either by taking them as arguments or returning them. 


// Higher-order function that takes a function as an argument 

function operate(x, y, operation){ 

    return operation(x, y); // calls the passed function with x and y 

} 

 

// function to be passed as arguments 

const add = (a, b) => a + b; // arrow function for addition 

const multiply = (a, b) => a * b; // arrow function for multiplication 

 

//using higher order function 

console.log(operate(5, 3, add)); // 8 

console.log(operate(5,3, multiply)); // 15 




2. What is call(), apply(), bind()?

Call() -- if we want to create second memory location will interact with 1st memory location.

Apply – if we want to pass array instead of independent parameter

Bind() - merge memory location 1 and memory location 2 -->merge 2 memory locations-->new memory location.

What is the USE? Call function advanced function APPLY, call and apply advanced version is bind().
Purpose is same. Call, bind, apply –used to access 2 objects in different memory location


3. What is shallow copy and deep copy?

A shallow copy creates a new object with references to the same memory locations as the original object for nested properties. 
This means changes to nested objects in the copy will affect the original object.

javascript example: 
const originalObject = { a: 1, b: { c: 2 } };
const shallowCopy = { ...originalObject };

shallowCopy.b.c = 3;
console.log(originalObject.b.c); // Output: 3

Deep Copy
A deep copy creates a new object with new memory locations for all nested properties, ensuring changes to the copy don't affect the original object.

JavaScript Example:

javascript
const originalObject = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(originalObject));

deepCopy.b.c = 3;
console.log(originalObject.b.c); // Output: 2

4. how do you optimnize performance in React app?

1. Memoization with useMemo and useCallback:  Use this hooks to memoize values and, reducing unnecessary recalculations.
2. Optimizing Renders with React.Fragment: Use it to avoid unnecessary wrapper elements that could cause additional DOM nodes.
3. Lazy loading with React.lazy: Use it to load components lazily, reducing the intial bundle size and imporving intial loading performance.
4. Code splitting: Employ code splitting to divide your application into smaller chunks that are loaded on demand, improving initial load times.
5. Optimizing Images and Assets:  Compress and optimize images, use responsive images and leverage lazy loading for images to reduce network and rendering overhead.


5. What is promise.All() and race?
Promise.all takes an array of promises and waits for all of them to resolve. 
If any promise rejects, the entire Promise.all immediately rejects with that reason

Key Points:
Resolves when all promises are successful.
Rejects if any promise fails.
Returns an array of results in the same order as the input.

Example:
javascript

CopyEdit
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then(results => console.log(results))  // [1, 2, 3]
  .catch(err => console.error(err));


6. What is callback hell? how to avoid it?
Callback hell" refers to a situation in programming where multiple asynchronous operations are handled using nested callback functions,
creating a complex and difficult-to-read code structure, often resembling a pyramid shape; 
to avoid it, use techniques like Promises and the async/await syntax to manage asynchronous operations in a more linear fashion,
making your code cleaner and easier to maintain. 


7. What is virtual DOM? example?
Suppose line of code is changed , processing is done on particular line. 
It will process the whole code in real DOM. Virtual DOM is faster.

8. How do you integrate API in front end?
To integrate an API in a React.js frontend application, you'll typically use the fetch API or
a library like Axios to make HTTP requests, handle responses, and then display the data in your React components


9. If the network request --> API response is 400 ? how do you proceed?
Test API endpoint in Postman or similar tools to isolate frontend vs. backend issues
Check for network connectivity problems
Verify the API base URL is correct for the environment (dev/staging/prod)


10. what is local storage and session storage? advantages?

Session Storage and Local Storage are both part of the Web Storage API that allow you to store key-value pairs in a user's browser, but they have different use cases and lifecycles.
1. Session Storage
Scope: Per tab or window. Data is only available for the duration of the page session.
Lifetime: Cleared when the tab or browser is closed.
Capacity: ~5MB (varies by browser).
Access: Same-origin policy — only accessible from pages with the same protocol, host, and port.
Use Cases:
Temporary data like form inputs, filters, or UI states that shouldn't persist after the session ends.
Storing data that shouldn't be shared across tabs/windows.
Example:
javascript
CopyEdit
// Set item
sessionStorage.setItem("user", "John");

// Get item
let user = sessionStorage.getItem("user");

// Remove item
sessionStorage.removeItem("user");


2. Local Storage
Scope: Per domain. Data is persistent across sessions and tabs.
Lifetime: Remains even after closing the browser, until explicitly cleared.
Capacity: ~5-10MB (varies by browser).
Access: Same-origin policy.
Use Cases:
Persistent user preferences (e.g., theme settings).
Caching data (e.g., API responses) for faster page loads.
Shopping cart data in e-commerce sites.
Example:
javascript
CopyEdit
// Set item
localStorage.setItem("theme", "dark");

// Get item
let theme = localStorage.getItem("theme");

// Remove item
localStorage.removeItem("theme");



11. What is code splitting?

Code Splitting in React
Code splitting is a technique that breaks your app into smaller chunks (bundles) that can be loaded on demand, 
improving initial load performance. Here's how to implement it in React:

React.lazy and Suspense
The most common approach using React's built-in features:
jsx
Copy
import React, { Suspense, lazy } from 'react';

// Instead of: import ExpensiveComponent from './ExpensiveComponent';
const ExpensiveComponent = lazy(() => import('./ExpensiveComponent'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <ExpensiveComponent />
      </Suspense>
    </div>
  );
}

}



12. What is asynchronous and synchronous operations?


13. What is connect?


14. What is controlled and uncontrolled components?

Characteristics of Controlled Components:
Form values are stored in React state
Changes are handled through event handlers
The component explicitly sets and updates the input value
More predictable as React controls the input state at all times
Enables immediate validation, conditional disabling, and formatting

Characteristics of Uncontrolled Components:
Form values are stored in the DOM, not in React state
Accessed using refs rather than event handlers
Uses defaultValue instead of value for initial values
Simpler code with less boilerplate for basic forms
Helpful when integrating with non-React code



15. coding question
//"programming" string - 
//find the first duplicate character from given string.




//"programming" string - 
//find the first duplicate character from given string.

const findduplicate = (str) =>{
  const chars = [];
  let charFound = null;
  for(let i = 0 ; i < str.length; i++){
    if(chars.includes(str[i])){
        charFound = str[i]
    }else{
      chars.push(str[i])
    }

    
     console.log("debug", chars , charFound, str[i])
     if(charFound) break;

  }
  return charFound;
}

console.log(findduplicate("apple"));





promise.all()

==================================


1. Have you used React custom hook? 

Yes, I have used React custom hooks. Custom hooks in React allow you to extract and reuse stateful logic across multiple components, 
which helps in keeping components clean and more maintainable. 
They follow the same naming convention as built-in hooks (starting with "use"), and they allow you to share logic without repeating code.

For example, I’ve created custom hooks like useFetch for handling API requests or useForm to manage form state.

useResize custom hook with different screens. breakpoint occur return screen size 1400 px Screensize mobile and desktop.

useMediaQuery:
Enables components to adapt to different screen sizes or devices by conditionally rendering content based on media queries.


2. event loop?

The event loop in React, as in all JavaScript environments, manages asynchronous operations, ensuring the UI remains responsive. 
It continuously monitors the call stack and the task queue.
When the call stack is empty, the event loop takes the first task from the queue and places it onto the call stack for execution.

3. which version of react? v18

4. CSS Grid vs Flex
In CSS, "Grid" refers to the CSS Grid Layout, which allows for two-dimensional positioning of elements by creating a grid with rows and columns, 
while "Flex" refers to Flexbox, a layout system designed for one-dimensional alignment, meaning you can arrange elements in either a row or a column only; 

5. How to optimization performance in HTML?

To optimize HTML performance, 
1. focus on minimizing file size by minifying code, 
2. optimizing images, 
3. leveraging browser caching, 
4. using a Content Delivery Network (CDN), 
5. deferring JavaScript loading, and 
6. ensuring semantic and valid HTML markup

6. coding question:

https://dummyjson.com/docs/users

show FName, LastName, Age

users.tsx


import react from "react";

const Users = ({ firstName, lastName, age }) => {
  return (
    <div className="user-card">
      <p>{firstName}</p>
      <p>{lastName}</p>
      <p>{age}</p>
    </div>
  );
};

export default Users;

app.tsx
import { useEffect, useState } from "react";
import "./styles.css";
import Users from "./Users";

export default function App() {
  const [users, setUsers] = useState([]);

  const fetchApi = (url) => {
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        console.log(data);
        setUsers(data.users);
      });
  };
  useEffect(() => {
    fetchApi("https://dummyjson.com/users");
  }, []);

  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
      {users.length && users.map((props) => <Users {...props} />)}
    </div>
  );
}

6. Middleware used? Redux, redux-thunk, redux-saga



====================================================================================

node.js questions
------------------------------------------
1. Can you write SQL Query for 2 tables, 

student table --> id, name

table 2:--> table for change, contains id, studentid 


join the table 1, 2 and fetch the name

Status : 1 fetch only those


innerjoin--> where clause



Output: To join these two tables and fetch the name from the student table using the studentid from the second table (let's call it change), you can use an INNER JOIN like this:

SELECT s.name
FROM student s
JOIN change c ON s.id = c.studentid;


============================

1. What is ExpressJS? Express is a flexible Node.js web application framework that provides a wide set of features to develop web and mobile applications

2. What is an Event Loop in Node.js?
Event loops handle asynchronous callbacks in Node.js. 
It is the foundation of Node.js's non-blocking input/output in Node.js, making it one of the most important environmental features.

3. For Node.js, why does Google use the V8 engine?
The V8 engine, developed by Google, is open-source and written in C++. Google Chrome makes use of this engine. 
V8, unlike the other engines, is also utilized for the popular Node.js runtime. 
V8 was initially intended to improve the speed of JavaScript execution within web browsers. 
Instead of employing an interpreter, V8 converts JavaScript code into more efficient machine code to increase performance. 
It turns JavaScript code into machine code during execution by utilizing a JIT (Just-In-Time) compiler, as do many current JavaScript
engines such as SpiderMonkey or Rhino (Mozilla).


Describe Node.js exit codes?

Node.js exit codes are numerical values that a Node.js process returns to the operating system upon completion. 
These codes signal whether the process completed successfully or encountered an error.

0:
Success. Indicates that the program executed without errors.
1:
Uncaught Fatal Exception. Signifies that an uncaught exception occurred and was not handled by a try...catch block or an uncaughtException event handler.
2:
Unused (Reserved by Bash). This code is reserved for misuse of shell built-ins in Bash.
3:
Internal JavaScript Parse Error. Occurs when the JavaScript source code within Node.js's bootstrapping process encounters a parsing error. This is rare and typically happens during Node.js development.
>4:
User-defined errors. Codes above 4 can be used to indicate custom error conditions within an application.




